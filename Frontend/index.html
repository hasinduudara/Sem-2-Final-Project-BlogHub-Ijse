<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlogHub - Welcome</title>
    <!-- Bootstrap CSS CDN -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      xintegrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM"
      crossorigin="anonymous"
    />
    <!-- Inter Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="/Frontend/assets/image/blogging.png" />
    <style>
      body {
        font-family: "Inter", sans-serif;
        overflow: hidden; /* Prevent scrollbars due to canvas */
        background-color: #1a1a1a; /* Dark gray for black & white theme */
        color: #f0f0f0; /* Light gray for contrast */
      }
      #webgl-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
      }
      .content-overlay {
        position: relative;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 1rem;
        text-align: center;
      }
      .card-custom {
        background-color: rgba(
          34,
          34,
          34,
          0.8
        ); /* Slightly lighter dark gray for card */
        backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 100, 100, 0.5); /* Gray border */
        transition: transform 0.5s ease-in-out;
      }
      .card-custom:hover {
        transform: scale(1.05);
      }

      /* Custom gradient text and pulse animation for black & white theme */
      .gradient-text {
        background-image: linear-gradient(
          to right,
          #cccccc,
          #999999
        ); /* Light gray to darker gray */
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: pulse-slow 3s infinite ease-in-out;
      }

      @keyframes pulse-slow {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* Custom gradient button for black & white theme */
      .btn-gradient-custom {
        background-image: linear-gradient(
          to right,
          #808080,
          #555555
        ); /* Medium gray to dark gray */
        border: none;
        color: #ffffff; /* White text on button */
        transition: all 0.3s ease-in-out;
      }
      .btn-gradient-custom:hover {
        background-image: linear-gradient(
          to right,
          #666666,
          #333333
        ); /* Darker shades on hover */
        transform: scale(1.1);
        box-shadow: 0 0 0 0.25rem rgba(128, 128, 128, 0.5); /* Gray focus ring effect */
      }
    </style>
  </head>
  <body>
    <!-- WebGL Canvas for 3D animation -->
    <canvas id="webgl-canvas"></canvas>

    <!-- Content Overlay -->
    <div class="content-overlay">
      <div
        class="card-custom p-4 p-md-5 rounded-4 shadow-lg mx-auto"
        style="max-width: 500px"
      >
        <h1 class="display-4 fw-bold mb-4 gradient-text">
          Welcome to BlogHub!
        </h1>
        <p class="lead text-light mb-5">
          Your central hub for captivating stories, insightful articles, and
          shared knowledge. Dive into a universe of ideas!
        </p>
        <!-- Changed button text and added direct HTML link -->
        <a
          href="/Frontend/pages/login-and-register/login-and-register.html"
          class="btn btn-lg btn-gradient-custom text-white rounded-pill shadow-lg d-inline-block"
          id="login-button"
        >
          Start Now
        </a>
      </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, renderer, particles, particleMesh;
      let mouseX = 0,
        mouseY = 0;
      let windowHalfX = window.innerWidth / 2;
      let windowHalfY = window.innerHeight / 2;

      // Initialize the 3D scene
      function init() {
        // Scene
        scene = new THREE.Scene();

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 10;

        // Renderer
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("webgl-canvas"),
          alpha: true, // Allow transparency
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Particles
        const particleCount = 1000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        // Changed particle colors to shades of gray/white for black & white theme
        const color1 = new THREE.Color(0xffffff); // White
        const color2 = new THREE.Color(0xcccccc); // Light Gray
        const color3 = new THREE.Color(0x999999); // Medium Gray

        for (let i = 0; i < particleCount; i++) {
          // Position particles randomly in a sphere
          const r = 5 + Math.random() * 5; // Radius
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1); // Random distribution on sphere
          positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i * 3 + 2] = r * Math.cos(phi);

          // Assign random colors
          const randColor = Math.random();
          if (randColor < 0.33) {
            color1.toArray(colors, i * 3);
          } else if (randColor < 0.66) {
            color2.toArray(colors, i * 3);
          } else {
            color3.toArray(colors, i * 3);
          }
        }
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: 0.1,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        });
        particleMesh = new THREE.Points(geometry, material);
        scene.add(particleMesh);

        // Lines connecting nearby particles (representing a "hub")
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0x888888, // Grayish lines for black & white theme
          transparent: true,
          opacity: 0.1,
          blending: THREE.AdditiveBlending,
        });
        const lineGeometry = new THREE.BufferGeometry();
        const maxConnections = 20; // Max lines to draw
        const maxPointsPerLine = 2; // Each line has 2 points
        const linePositions = new Float32Array(
          particleCount * maxConnections * maxPointsPerLine * 3
        );
        let lineIndex = 0;

        const tempVertex = new THREE.Vector3();
        const distances = [];

        for (let i = 0; i < particleCount; i++) {
          tempVertex.fromArray(positions, i * 3);
          distances.length = 0; // Clear distances for current particle

          for (let j = 0; j < particleCount; j++) {
            if (i === j) continue;
            const otherVertex = new THREE.Vector3().fromArray(positions, j * 3);
            const dist = tempVertex.distanceTo(otherVertex);
            if (dist < 2) {
              // Connect particles within a certain distance
              distances.push({ dist: dist, index: j });
            }
          }

          distances.sort((a, b) => a.dist - b.dist);

          for (let k = 0; k < Math.min(distances.length, 3); k++) {
            // Connect to up to 3 closest particles
            const targetIndex = distances[k].index;

            linePositions[lineIndex * 6] = positions[i * 3];
            linePositions[lineIndex * 6 + 1] = positions[i * 3 + 1];
            linePositions[lineIndex * 6 + 2] = positions[i * 3 + 2];

            linePositions[lineIndex * 6 + 3] = positions[targetIndex * 3];
            linePositions[lineIndex * 6 + 4] = positions[targetIndex * 3 + 1];
            linePositions[lineIndex * 6 + 5] = positions[targetIndex * 3 + 2];
            lineIndex++;
          }
        }

        lineGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(linePositions.slice(0, lineIndex * 6), 3)
        );
        const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lines);

        // Event Listeners
        window.addEventListener("resize", onWindowResize, false);
        document.addEventListener("mousemove", onDocumentMouseMove, false);
        document.addEventListener("touchstart", onDocumentTouchStart, false);
        document.addEventListener("touchmove", onDocumentTouchMove, false);
      }

      // Handle window resize
      function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Handle mouse movement for camera
      function onDocumentMouseMove(event) {
        mouseX = (event.clientX - windowHalfX) * 0.005;
        mouseY = (event.clientY - windowHalfY) * 0.005;
      }

      // Handle touch start for camera
      function onDocumentTouchStart(event) {
        if (event.touches.length === 1) {
          mouseX = (event.touches[0].pageX - windowHalfX) * 0.005;
          mouseY = (event.touches[0].pageY - windowHalfY) * 0.005;
        }
      }

      // Handle touch move for camera
      function onDocumentTouchMove(event) {
        if (event.touches.length === 1) {
          event.preventDefault();
          mouseX = (event.touches[0].pageX - windowHalfX) * 0.005;
          mouseY = (event.touches[0].pageY - windowHalfY) * 0.005;
        }
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Rotate particles slowly
        particleMesh.rotation.x += 0.0005;
        particleMesh.rotation.y += 0.001;

        // Move camera slightly based on mouse/touch
        camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.y += (-mouseY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);

        renderer.render(scene, camera);
      }

      // Start the animation on window load.
      window.onload = function () {
        init();
        animate();
      };
    </script>
    <!-- Bootstrap JS CDN (optional, for components that require JS) -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
      xintegrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/6si/I3wWfBU0"
      crossorigin="anonymous"
    ></script>
  </body>
</html>
